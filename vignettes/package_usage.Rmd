---
title: "Package Usage"
author: "Xianghui Dong"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Package Usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction
- how to use package functions in analysis.
- Since most functions belong to a workflow, it's easier to put all functions usage examples in a workflow example than giving individual code examples in function help.
- test code, write document individually, but not to knit document in building site until final version.
- compare the ctmm vignette

```{r libraries and data, eval=FALSE}
library(ctmm)
library(ctmmweb)
data(buffalo)

#basic data structure
merged_data <- merge_tele(buffalo)
dt <- merged_data$data
info <- merged_data$info
```

basic intro on data structure

## Visualization

```{r plot location and time, eval=FALSE}
# how to take subset, this is to simulate the row selection in app
selected_dt <- dt[identity %in% c("Gabs", "Queen")]

# plot
plot_loc(selected_dt, dt)
plot_loc_facet(selected_dt)
plot_time(selected_dt)
# take the ggplot2 object to further customize it
plot_loc(selected_dt, dt) +
  ggplot2::ggtitle("Locations of Buffalos") +
  # override the default left alignment of title and make it bigger
  ctmmweb:::CENTER_TITLE
# export plot
g <- plot_loc(selected_dt, dt)
ggplot2::ggsave("test.png", g)
```

## model summary table

```{r model summary, eval=FALSE}
sample_tele(buffalo[[1]], 100)
data_sample <- sample_tele_list(buffalo, 100)
model_fit_res <- par_fit_tele(data_sample)
summary_model_fit(model_fit_res)

# need to prepare model list dt like in app.
```

- operations on model table
- model list, names of list

## variogram, home range, occurrence

```{r variogram, eval=FALSE}

```

```{r home range}

```

- with 100 sample, the Gabs 2nd model, OUF ani have error in occurrence plot? report this with reproducible code, also test with different sample size.
```{r occurrence}

```

## map

```{r point map, eval=FALSE}
point_map(selected_dt, dt)
# add control. This is not a part of point_map function because we can only add control once and after all layers are added. If we want to overlay home range over points, we need to add control after home range layer are added.
point_map(selected_dt, dt) %>% 
  add_control(get_names(selected_dt))

# save map to html

```

- to add home range, there is no wrapped less parameter version because we need lots of information and need some flexibility (base map, controls have to be added later). It's actually easier to use the app to add home range, since it involves model selection, color assignment etc
- need to export add_home_range_list, maybe put names to range_list names.
```{r home range map, eval=FALSE}
base_map() %>% 
  add_home_range_list(hrange_list, hr_levels, hr_color_vec) %>% 
  add_control(model_names)

point_map(selected_dt, dt) %>% 
  add_home_range_list(hrange_list, hr_levels, hr_color_vec) %>% 
  add_control(c(get_names(selected_dt), model_names))

# save to html

```

## Other utility functions
### generic parallel function usage
```{r parallel, eval=FALSE}
# generic parallel usage
```
