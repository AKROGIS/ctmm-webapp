---
title: "Package Usage"
author: "Xianghui Dong"
date: "`r Sys.Date()`"
output: 
  html_document: 
    highlight: haddock
    theme: flatly
vignette: >
  %\VignetteIndexEntry{Package Usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "fig/"
)
```

## Introduction

This document demonstrate the usage of package functions in analysis. Since most of the functions are parts of a workflow, it's better to explain them together than giving separate code examples in function help.

First we load the libraries and prepare the data. Note a sample was generated so that the model fitting process can finish in seconds instead of minutes.

```{r libraries and data, eval=TRUE}
library(ctmm)
library(ctmmweb)
data(buffalo)
# take a 100 point sample from each animal to speed up model fitting etc
data_sample <- sample_tele_list(buffalo, 100)
```

### Basic data structure

To plot multiple animals location with `ggplot2`, we need to merge all location data into a single `data.frame`. `merge_tele` will merge `ctmm` `telemetry` object/list into a list of location `data.table` and information `data.table`. `data.table` is compatible with `data.frame` but has much better performance.

```{r basic data structure}
# basic data structure
merged_data <- merge_tele(buffalo)
# a list of locations data.table/data.frame and information table
dt <- merged_data$data
info <- merged_data$info
```

In `dt`: 

- `identity` are animal names
- `id` are animal names as a factor. We will need this when we want to maintain the level information.

```{r dt}
knitr::kable(head(dt))
```


```{r info}
knitr::kable(info)
```


In app we can select a subset of full data by slecting rows in the data summary table 1.

![](pic/01_summary_table.png){ width=75% }


To select a subset in script, we can select animal names for `identity` column or numbers for `id` factor column in `dt` with `data.table` syntax. `data.table` is also `data.frame` so you can use `data.frame` synatax too.

It's suggested to always select a subset from full data like this, because the subset will carry the `id` column which still hold all animal names in levels, then a consistent color mapping can be maintained(otherwise `ggplot2` will always draw first animal in same color).

```{r select subset}
# select by identity column
selected_dt1 <- dt[identity %in% c("Gabs", "Queen")]
# select by id factor column value
dt[as.numeric(id) %in% c(1, 3)]
```

## Visualization

You can reproduce most of the plots in `Visualization` page with functions. 

```{r plot location and time, eval=TRUE}
# plot animal locations
plot_loc(dt)
# plot a subset only. Note the color mapping is consistent because selected_dt1 id column hold all animal names in levels.
plot_loc(selected_dt1)
# with subset and full data set both provided, subset will be drawn with full data as background. 
plot_loc(selected_dt1, dt)
# location in facet
plot_loc_facet(selected_dt1)
# sampling time
plot_time(selected_dt1)
# take the ggplot2 object to further customize it
plot_loc(selected_dt1, dt) +
  ggplot2::ggtitle("Locations of Buffalos") +
  # override the default left alignment of title and make it bigger
  ctmmweb:::CENTER_TITLE
# export plot
g <- plot_loc(selected_dt1, dt)
ggplot2::ggsave("pic/test.png", g)
```



## Variogram

We can plot variograms in various modes. 

Empirical variograms based on telemetry data
```{r variogram 1, fig.height=8}
vario_list <- lapply(data_sample, ctmm::variogram)
# names of vario_list are needed for figure titles
names(vario_list) <- names(data_sample)
plot_vario(vario_list)
# sometimes the default figure settings doesn't work in some systems, you can clear the plot device then use a smaller title size
# dev.off()
# plot_vario(vario_list, cex = 0.55)
```

Variogram of guesstimated models from `ctmm::ctmm.guess` on telemetry data.

```{r variogram 2, fig.height=8}
guess_list <- lapply(data_sample,
                     function(tele) 
                       ctmm::ctmm.guess(tele, interactive = FALSE))
plot_vario(vario_list, guess_list)
```

## Model summary table

Fit models on data in parallel.

```{r model summary, eval=TRUE}
# fit models in parallel.
model_fit_res <- par_fit_tele(data_sample)
# a data.table of models information summary
model_summary_dt <- summary_model_fit(model_fit_res)
# you can also open it with RStudio's data.frame viewer
knitr::kable(model_summary_dt)
```

There could be multiple models fitted for each animal if they are validate candidates. In the app you can select a subset of models then check their variograms, home ranges and occurrences. You will aslo need to select a subset of models in R script.

`model_fit_res` hold every model for same animal under a list item of animal name. 
![](pic/05_model_res_structure.png){ width=50% }

We need to convert it into a flat list to make the selection easier.

```{r flat model list}
# the nested structure of model fit result
names(model_fit_res)
names(model_fit_res[[1]])
# convert to a flat list
model_list <- list_model_fit(model_fit_res)
names(model_list)
```

Then we can find the model names in model summary table by `model_no` or `model_type`. The code here is in `data.table` syntax, but you can use the table as `data.frame` if you want.

```{r select models in summary table}
# select subset in model summary table by model_no
knitr::kable(model_summary_dt[model_no %in% c(1, 3, 10, 11, 12, 13)])
# select by model type
knitr::kable(model_summary_dt[model_type == "OU anisotropic"])
# select first(best) model for each animal using the smallest AICc value
knitr::kable(model_summary_dt[dAICc == 0])
# Because each model have 3 rows, the `estimte == "ML"` filter can make sure each model only be selected once. 
knitr::kable(model_summary_dt[estimate == "ML"])
# Combine this condition with filter above to select models
# The expression is enclosed with () to enable automatical printing of result. Both model_name and identity are selected in same filter. We need the model_name to filter the model list, and the animal name to filter the variograms
(selected_names <- model_summary_dt[(estimate == "ML") &
  (model_no %in% c(1, 3, 10, 11, 12, 13)), .(model_name, identity)])
```

Once you have selected the models in summary table, you can filter the actual models list with model names. Note this is a different subset from `selected_dt1` above.

```{r filter model list}
# filter model list by model names to get subset of model list.
selected_model_list <- model_list[selected_names$model_name]
```

Now we can plot variograms with selected models. Note the `selected_vario_list` need to match with `selected_model_list` in length and animal, so they are based on same data.

```{r variogram 3, fig.height=8}
# get corresponding variograms by animal names.
selected_vario_list <- vario_list[selected_names$identity]
# specify a different color for model
plot_vario(selected_vario_list, selected_model_list, model_color = "purple")
```

## Home range

```{r home range, fig.height=10}
# calculate home range with ctmm::akde. Note we didn't use parallel here because we want to calculate all animals together to put them in same grid.
selected_tele_list <- data_sample[selected_names$identity]
hrange_list <- akde(selected_tele_list, CTMM = selected_model_list)
# name by model name
names(hrange_list) <- names(selected_model_list)
# summary of each home range. There is no summary table function here because we borrowed the model table in app to make the home range summay table. To reproduce that in functions need model table/model_fit_res and the selection as parameters, which will be quite awkward. If there is a strong request from users, a summary table function can be added.
lapply(hrange_list, summary)
# plot home range
plot_ud(hrange_list)
# plot home range with location overlay
plot_ud(hrange_list, tele_list = selected_tele_list)
# plot with different level.UD values
plot_ud(hrange_list, level_vec = c(0.50, 0.95), tele_list = selected_tele_list)
```

## Occurrence

```{r occurrence, fig.height=10}
# calculate occurrence in parallel
occur_list <- par_occur(selected_tele_list, selected_model_list)
# plot occurrence. Note tele_list is not needed here because the location overlay usually interfere with occurrence plot.
plot_ud(occur_list, level_vec = c(0.50, 0.95))
```

## Map

We can build an interactive online map.

```{r point map, eval=TRUE}
# this is needed for using pipe operator
library(leaflet)
# selecte_dt1 is used for visualization plot. all the model selections above are based on a different subset. We need to get corresponding dt subset for model selections
selected_dt2 <- dt[identity %in% names(selected_tele_list)]
point_map(selected_dt2)
point_map(dt)
# save map to html. It will be self contained and can be shared.
htmlwidgets::saveWidget(point_map(selected_dt2), file = "point_map.html")
```

Home range map need more parameters. See their help documents for detailed explanations.

```{r home range map, eval=TRUE}
range_map(hrange_list, 0.95, rainbow(length(hrange_list)))
# note selected_dt2 is corresponding to hrange_list
point_range_map(selected_dt2, hrange_list, 0.95, rainbow(length(hrange_list)))
```

## Other utility functions
code example for each function since we didn't put code example in help.
- disctance, speed outlier

### generic parallel function usage
```{r parallel, eval=FALSE}
# sample a telemetry object to test time consuming processes with less time
sample_tele(buffalo[[1]], 100)
# generic parallel usage
```
